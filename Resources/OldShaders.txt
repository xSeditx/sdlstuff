


/*------------------------------------------------------------------------------------- 
PerVertex Vertex Lighting shader


#version 120

attribute vec3 VertexPosition;
attribute vec3 VertexNormal;
attribute vec4 VertexColor;

varying vec4 color;
void main()
{
vec3 lpos = vec3(0,0,0);
vec3 nVertexNormal = normalize(VertexNormal);
 vec3 modelViewVertex = vec3(gl_ModelViewMatrix * vec4(VertexPosition, 1.0));
 vec3 modelViewNormal = vec3(gl_ModelViewMatrix * vec4(nVertexNormal, 0.0));
 float distance = length(lpos - modelViewVertex);
 vec3 lightVector = normalize(lpos - modelViewVertex);
 float diffuse = max(dot(modelViewNormal, lightVector), 1.0);
 diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));


color = VertexColor * diffuse;
gl_Position = gl_ModelViewProjectionMatrix * vec4(VertexPosition.xyz, 1.0f);
}
________________________________________________________________________________________*/










/*  PerPixel Vertex shader
_________________________________________________________________________________________________________

uniform mat4 u_MVPMatrix;      // A constant representing the combined model/view/projection matrix.
uniform mat4 u_MVMatrix;       // A constant representing the combined model/view matrix.
 
attribute vec4 a_Position;     // Per-vertex position information we will pass in.
attribute vec4 a_Color;        // Per-vertex color information we will pass in.
attribute vec3 a_Normal;       // Per-vertex normal information we will pass in.
 
varying vec3 v_Position;       // This will be passed into the fragment shader.
varying vec4 v_Color;          // This will be passed into the fragment shader.
varying vec3 v_Normal;         // This will be passed into the fragment shader.
 
// The entry point for our vertex shader.
void main()
{
    // Transform the vertex into eye space.
    v_Position = vec3(u_MVMatrix * a_Position);
 
    // Pass through the color.
    v_Color = a_Color;
 
    // Transform the normal's orientation into eye space.
    v_Normal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));
 
    // gl_Position is a special variable used to store the final position.
    // Multiply the vertex by the matrix to get the final point in normalized screen coordinates.
    gl_Position = u_MVPMatrix * a_Position;
}
_______________________________________________________________________________________________________*/







#FRAGMENTS













/*   PerPixel Lighting Shader
precision mediump float;       // Set the default precision to medium. We don't need as high of a
                               // precision in the fragment shader.
uniform vec3 u_LightPos;       // The position of the light in eye space.
 
varying vec3 v_Position;       // Interpolated position for this fragment.
varying vec4 v_Color;          // This is the color from the vertex shader interpolated across the
                               // triangle per fragment.
varying vec3 v_Normal;         // Interpolated normal for this fragment.
 
// The entry point for our fragment shader.
void main()
{
    // Will be used for attenuation.
    float distance = length(u_LightPos - v_Position);
 
    // Get a lighting direction vector from the light to the vertex.
    vec3 lightVector = normalize(u_LightPos - v_Position);
 
    // Calculate the dot product of the light vector and vertex normal. If the normal and light vector are
    // pointing in the same direction then it will get max illumination.
    float diffuse = max(dot(v_Normal, lightVector), 0.1);
 
    // Add attenuation.
    diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));
 
    // Multiply the color by the diffuse illumination level to get final output color.
    gl_FragColor = v_Color * diffuse;
}
*/









 // RANDOM GARBAGE
 ===========================================================================

 
///* first transform the normal into eye space and
//   normalize the result */
//   normal = normalize(gl_NormalMatrix * gl_Normal);
///* pass the halfVector to the fragment shader */
//    halfVector = gl_LightSource[0].halfVector.xyz;
/* Compute the diffuse, ambient and globalAmbient terms */
//    diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
//    ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;
//    ambient += gl_LightModel.ambient * gl_FrontMaterial.ambient;
//    gl_Position = ftransform();

//  out vec3 Normal;
//    
//  void main()
//  {
//      gl_Position = projection * view * model * vec4(aPos, 1.0);
//      FragPos = vec3(model * vec4(aPos, 1.0));
//      Normal = aNormal;
//	Normal = normalize(vec3(gl_ModelViewMatrix * vec4(VertexNormal,0.0)));

   // Normal = mat3(transpose(inverse(ModelMatrix))) * VertexNormal.xyz; 

//	;
